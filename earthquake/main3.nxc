
// Sample time, determined the reaction rate
//#define dt 20
#define dt 50

// NXT 2.0 Color sensor connected to port 1.
#define COLORSENSOR SENSOR_1

sub print(int line_num, string name, int value) {
	TextOut(0, line_num, "                        ");
	TextOut(0, line_num, name);
	NumOut(40, line_num, value);
}


int error_stable = 0;
int error_cycle_lowest = 0;
bool error_cycle_lowest_set = false;

/* Scan (starting from rightmost position) to the leftmost position and back
 * again and detect the line offset error. An error of 0 means the robot does
 * not need to change course, a positive error means the robot must steer right,
 * and a negative error means the robot must steer left.
 */
#define SCAN_ANGLE 70
#define SCAN_SPEED 90
task scan_color_sensor() {
	bool right_to_left = true;
	while (true) {
		int angle = right_to_left ? SCAN_ANGLE : -SCAN_ANGLE;
		RotateMotorEx(OUT_C, SCAN_SPEED, angle, 0, false, false);
		right_to_left = !right_to_left;
				
		// Play a sound if the line wasn't found during the last cycle.
		if (!error_cycle_lowest_set) {
			PlayTone(TONE_B7, 1);
			// TODO(jhibberd) Instigate line search behaviour.
		}
		error_stable = error_cycle_lowest;
		error_cycle_lowest = 0;
		error_cycle_lowest_set = false;
	}
}


float error = 0;
float previous_error = 0;
float setpoint = 0;
float actual_position = 0;
float proportional = 0;
int integral = 0;
float derivative = 0;
float output = 0;
float left = 0;
float right = 0;
int speed = 30;

// NOTE: rotation 0=far right, 60(SCAN_ANGLE)=far left
task read_color_sensor() {
	float setpoint = 1;
	while (true) {

		float actual_position = COLORSENSOR;
   		if (actual_position == setpoint) {	

			// Returns angle between 0 (far right) and SCAN_ANGLE (far left)
			// 60 .. 30 .. 0
			// An angle of SCAN_ANGLE/2 should be straight ahead
			long rotation = MotorRotationCount(OUT_C);
			print(LCD_LINE3, "R1", rotation);   			
   			int std_rotation = rotation - (SCAN_ANGLE/2);
   			std_rotation = -std_rotation;
   			print(LCD_LINE4, "R2", std_rotation);  
   			
   			print(LCD_LINE5, "E", error_stable);
   			print(LCD_LINE6, "O", output);
   			print(LCD_LINE7, "L", left);
   			print(LCD_LINE8, "R", right);
   			
   			// Need error that's closest to zero (on either side)
   			// can use abs(error3)
   			if (!error_cycle_lowest_set || abs(std_rotation) < abs(error_cycle_lowest)) {
   				error_cycle_lowest = std_rotation;
   				error_cycle_lowest_set = true;
   			}
   			
   		}	
	}
}

task move() {
	while (true) {
		
		error = error_stable;

		error = error * 4;	

		if (error == 0) {
			left = speed;
			right = speed;
		} else if (error < 0) { // line is to the left
			left = speed - (abs(error) / 2);
			right = speed + (abs(error) / 2);
		} else if (error > 0) { // line is to the right
			left = speed + (error / 2);
			right = speed - (error / 2);
		}
		
		if (left > 100) {
			left = 100;
		}
		if (right > 100) {
			right = 100;
		}
		
		if (left >= 0) {
			OnFwd(OUT_A, left);
		} else {
			OnRev(OUT_A, abs(left));
		}
		if (right >= 0) {
			OnFwd(OUT_B, right);
		} else {
			OnRev(OUT_B, abs(right));
		}

		// Wait sample time.
		Wait(dt);		
	}
}

task main()
{
	// Set the motor speed.
	float speed=20;
	
	// Set the color sensor light on.
	SetSensorColorFull(IN_1);
	
	// Read the value from the light sensor at the start position. The sensor must be place above the black line.
	TextOut(1,LCD_LINE1,"Setpoint");
	setpoint = COLORSENSOR;
	NumOut(50,LCD_LINE1,setpoint);
	
	Precedes(scan_color_sensor, read_color_sensor, move);

}
